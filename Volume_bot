# lighter_volume_bot.py (Lighter ê±°ë˜ëŸ‰ ì±„ìš°ê¸° ë´‡ v2.5 - ìµœì¢… ì•ˆì •í™”)

import tkinter as tk
from tkinter import scrolledtext, messagebox
import asyncio
import threading
import aiohttp
from decimal import Decimal, ROUND_DOWN
from datetime import datetime
from typing import Optional
import time
import random
import json
import os 
import warnings 

# ============================================
# ğŸš¨ RuntimeWarning ë¬´ì‹œë¥¼ ìœ„í•œ ì½”ë“œ ë¸”ë¡:
# coroutine 'SignerClient.create_order' was never awaited ê²½ê³ ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤.
# ============================================
warnings.filterwarnings(
    "ignore", 
    category=RuntimeWarning, 
    message="coroutine 'SignerClient.create_order' was never awaited"
) 


# ============================================
# âš ï¸ ì—¬ê¸°ì— ë³¸ì¸ ì •ë³´ ì…ë ¥ ë° ì¸ë±ìŠ¤ ìˆ˜ì •
# ============================================
LIGHTER_API_KEY = "ë³¸ì¸ì½”ë“œì…ë ¥" # ğŸš¨ Private Key ì…ë ¥
LIGHTER_ACCOUNT_INDEX = 0  # ğŸš¨ ë³¸ì¸ì˜ ê³„ì • ì¸ë±ìŠ¤ ì…ë ¥
LIGHTER_API_KEY_INDEX = 0

# ì£¼ë¬¸ ì‹œ ì²´ê²°ì„ ë³´ì¥í•˜ê¸° ìœ„í•œ ìŠ¬ë¦¬í”¼ì§€ (1% ì ìš©)
SLIPPAGE_PCT = Decimal("0.01") 
MARKET_INDEX = 2048 # ETH/USDC
# ============================================

try:
    import lighter
except ImportError:
    lighter = None
    print("ê²½ê³ : 'lighter' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. pip install lighter ë¡œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”.")


def D(x):
    return Decimal(str(x))


class LighterClient:
    """Lighter API í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self, callback=None):
        self.base_url = "https://mainnet.zklighter.elliot.ai/api/v1"
        self.session: Optional[aiohttp.ClientSession] = None
        self.signer = None
        self.callback = callback
        self.order_counter = 0
        
    def log(self, msg):
        if self.callback:
            self.callback(msg)
            
    async def init(self):
        self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10))
        
        if LIGHTER_API_KEY and lighter:
            try:
                self.log(f"[INFO] SDK ì´ˆê¸°í™” ì‹œë„: Account Index={LIGHTER_ACCOUNT_INDEX}, Key Index={LIGHTER_API_KEY_INDEX}")
                
                self.signer = lighter.SignerClient(
                    url="https://mainnet.zklighter.elliot.ai",
                    account_index=LIGHTER_ACCOUNT_INDEX,
                    api_private_keys={LIGHTER_API_KEY_INDEX: LIGHTER_API_KEY},
                )
                self.log("[SUCCESS] âœ“ Lighter SDK ì—°ê²°")
                
            except ImportError:
                self.log("[ERROR] Lighter SDKê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. pip install lighter")
            except Exception as e:
                self.log(f"[ERROR] Lighter SDK ì—°ê²° ì‹¤íŒ¨ (í‚¤/ì¸ë±ìŠ¤ ë¬¸ì œ ê°€ëŠ¥ì„±): {e}")
                
    async def close(self):
        if self.session:
            await self.session.close()
            
    async def get(self, endpoint: str, params: dict = None) -> dict:
        url = f"{self.base_url}{endpoint}"
        try:
            async with self.session.get(url, params=params) as resp:
                if resp.status == 200:
                    return await resp.json()
                elif resp.status == 429:
                    self.log("[WARN] API ìš”ì²­ ì†ë„ ì œí•œ (429)")
                return {}
        except Exception as e:
            self.log(f"[ERROR] API í†µì‹  ì‹¤íŒ¨ ({endpoint}): {e}")
            return {}
    
    async def get_price(self) -> tuple:
        """Best Bid/Ask ì¡°íšŒ"""
        data = await self.get('/orderBookOrders', {'market_id': str(MARKET_INDEX), 'limit': '1'})
        
        best_bid = D("0")
        best_ask = D("0")
        
        bids = data.get('bids', [])
        asks = data.get('asks', [])
        
        if bids:
            best_bid = D(str(bids[0].get('price', '0')))
        if asks:
            best_ask = D(str(asks[0].get('price', '0')))
            
        return best_bid, best_ask
    
    async def get_balance(self) -> tuple:
        """ETH, USDC ì”ê³  ì¡°íšŒ"""
        data = await self.get('/account', {'by': 'index', 'value': str(LIGHTER_ACCOUNT_INDEX)})
        
        eth = D("0")
        usdc = D("0")
        
        accounts = data.get('accounts', [])
        if accounts:
            assets = accounts[0].get('assets', [])
            for asset in assets:
                symbol = asset.get('symbol')
                balance_value = asset.get('balance') or asset.get('available_balance')
                
                if balance_value is None:
                    continue
                
                try:
                    balance = D(str(balance_value))
                except Exception:
                    continue

                if symbol == 'ETH':
                    eth = balance
                elif symbol == 'USDC':
                    usdc = balance
                    
        return eth, usdc
    
    def get_next_order_id(self):
        self.order_counter += 1
        return int(time.time() * 1000) % (2**31) + self.order_counter
    
    
    # ğŸ’¡ V2.5: SDK ì‘ë‹µ íƒ€ì… ì˜¤ë¥˜ í•´ê²° (RespSendTx)
    async def create_order(self, is_ask: bool, amount: Decimal, price_ref: Decimal) -> dict:
        """ë§¤ìˆ˜/ë§¤ë„ ì‹¤í–‰ (IOC ì£¼ë¬¸)"""
        if not self.signer:
            return {'error': 'No signer'}

        try:
            # Lighterì˜ Atomic Unit ë³€í™˜ (ETH: 10^4, Price: 100)
            base_amount = int((amount * D(10**4)).to_integral_value(rounding=ROUND_DOWN))
            tick = D("0.01")
            
            # ìŠ¬ë¦¬í”¼ì§€ ì ìš©í•˜ì—¬ ì¦‰ì‹œ ì²´ê²° ìœ ë„
            if is_ask: # ë§¤ë„ (SELL)
                price_with_slippage = price_ref - max(price_ref * SLIPPAGE_PCT, tick)
            else: # ë§¤ìˆ˜ (BUY)
                price_with_slippage = price_ref + max(price_ref * SLIPPAGE_PCT, tick)
            
            price_int = int((price_with_slippage * D(100)).to_integral_value(rounding=ROUND_DOWN))

            self.log(f"[INFO] ì£¼ë¬¸ íŒŒë¼ë¯¸í„°: Amount={base_amount}, Price={price_int}, Ask={is_ask}")

            # ğŸš¨ V2.3 ìˆ˜ì •: awaitë¥¼ ì§ì ‘ ì ìš©í•˜ì—¬ ì½”ë£¨í‹´ ê°ì²´ ì˜¤ë¥˜ í•´ê²°
            res = await self.signer.create_order(
                market_index=MARKET_INDEX,
                client_order_index=self.get_next_order_id(),
                base_amount=base_amount,
                price=price_int,
                is_ask=is_ask,
                order_type=0,           
                time_in_force=1,        # IOC (Immediate-Or-Cancel)
                reduce_only=False,
                # order_expiry íŒŒë¼ë¯¸í„° ì œê±° (V2.4)
            )

            # Lighter SDKì˜ ì¼ë°˜ì ì¸ ë°˜í™˜ê°’ (tx, response, error) íŠœí”Œì„ ì–¸íŒ©í‚¹
            if isinstance(res, tuple) and len(res) == 3:
                tx_hash, resp, err = res
            else:
                self.log(f"[CRITICAL] SDK ì˜ˆìƒì¹˜ ëª»í•œ ë°˜í™˜ íƒ€ì…: {type(res)} / ê°’: {res}")
                return {'error': 'SDK returned unexpected object (non-tuple)'}
            
            if err:
                return {'error': err}
            
            # ğŸ’¡ V2.5 í•µì‹¬ ìˆ˜ì •: RespSendTx ê°ì²´ (ë”•ì…”ë„ˆë¦¬ê°€ ì•„ë‹Œ ì‘ë‹µ) ì²˜ë¦¬
            if not isinstance(resp, dict):
                self.log(f"[WARN] ì‘ë‹µì´ {type(resp)} ê°ì²´ì…ë‹ˆë‹¤. ì „ì†¡ ì„±ê³µìœ¼ë¡œ ê°„ì£¼.")
                filled_amount = amount
                avg_price = price_ref 
                
                return {'success': True, 'filled_amount': filled_amount, 'avg_price': avg_price, 'response': {'tx_hash': str(tx_hash)}}


            # ë”•ì…”ë„ˆë¦¬ ì‘ë‹µ (ê¸°ì¡´ ì²´ê²° ì •ë³´ íŒŒì‹± ë¡œì§)
            filled_amount = D("0")
            avg_price = D("0")
            
            fills = resp.get('fills') or resp.get('filled') or []
            if isinstance(fills, list) and fills:
                total_base = D("0")
                total_quote = D("0")
                for f in fills:
                    ba = D(str(f.get('filled_base_amount', f.get('base_amount', 0))))
                    pa = D(str(f.get('price', f.get('avg_price', 0))))
                    total_base += ba
                    total_quote += ba * pa
                if total_base > 0:
                    filled_amount = total_base
                    avg_price = (total_quote / total_base).quantize(D('0.0001'))
            
            # ì²´ê²°ëŸ‰ì´ 0ì´ë©´ IOC ì£¼ë¬¸ì€ ì·¨ì†Œëœ ê²ƒì…ë‹ˆë‹¤.
            if filled_amount == 0:
                 return {'error': 'Order cancelled (0 fill from IOC)', 'response': resp}
            
            return {'success': True, 'filled_amount': filled_amount, 'avg_price': avg_price, 'response': resp}
            
        except Exception as e:
            return {'error': f'Order execution failed: {e}'}


class VolumeBot:
    """ê±°ë˜ëŸ‰ ì±„ìš°ê¸° ë´‡"""
    
    def __init__(self, callback):
        self.callback = callback
        self.client = None
        
        self.running = False
        
        # ì„¤ì • (ê¸°ë³¸ê°’)
        self.min_amount = D("0.005")
        self.max_amount = D("0.015")
        self.min_interval = 30
        self.max_interval = 180
        self.trades_before_rest = 15
        self.rest_min = 30
        self.rest_max = 60
        
        # ìƒíƒœ
        self.trade_count = 0
        self.session_trades = 0
        self.total_volume = D("0")
        self.is_buy_turn = True
        self.eth_balance = D("0")
        self.usdc_balance = D("0")
        
    def log(self, msg):
        self.callback('log', msg)
        
    async def init(self):
        self.client = LighterClient(callback=self.log)
        await self.client.init()
            
    async def close(self):
        if self.client:
            await self.client.close()
    
    def get_random_amount(self) -> Decimal:
        min_f = float(self.min_amount)
        max_f = float(self.max_amount)
        amount = random.uniform(min_f, max_f)
        return D(str(amount)).quantize(D("0.001"))
    
    def get_random_interval(self) -> float:
        return random.uniform(self.min_interval, self.max_interval)
    
    def get_random_rest(self) -> float:
        minutes = random.uniform(self.rest_min, self.rest_max)
        return minutes * 60
    
    async def execute_trade(self):
        """ê±°ë˜ ì‹¤í–‰"""
        best_bid, best_ask = await self.client.get_price()
        
        if best_bid == 0 or best_ask == 0:
            self.log("[ERROR] ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨")
            return False
        
        amount = self.get_random_amount()
        
        if self.is_buy_turn:
            # ë§¤ìˆ˜ (Ask)
            cost = amount * best_ask
            if cost > self.usdc_balance:
                self.log(f"[WARN] USDC ì”ê³ ({self.usdc_balance:.2f}) ë¶€ì¡±. ë§¤ìˆ˜ ìŠ¤í‚µ.")
                return False

            self.log(f"[BUY] ì‹œë„ {amount} ETH @ í˜¸ê°€ ${best_ask}")
            result = await self.client.create_order(is_ask=False, amount=amount, price_ref=best_ask)
            
            if 'success' in result:
                filled = result.get('filled_amount', D('0'))
                avg_price = result.get('avg_price', D('0'))
                self.log(f"[SUCCESS] âœ“ ë§¤ìˆ˜ ì²´ê²°: {filled} ETH @ {avg_price:.4f}")
                self.total_volume += filled * avg_price
            else:
                self.log(f"[ERROR] ë§¤ìˆ˜ ì‹¤íŒ¨: {result.get('error')}")
                return False
        else:
            # ë§¤ë„ (Bid)
            if amount > self.eth_balance:
                amount = self.eth_balance.quantize(D("0.001"), ROUND_DOWN)
                if amount < self.min_amount:
                     self.log(f"[WARN] ETH ì”ê³ ({self.eth_balance:.4f}) ë¶€ì¡±. ë§¤ë„ ìŠ¤í‚µ.")
                     return False
            
            self.log(f"[SELL] ì‹œë„ {amount} ETH @ í˜¸ê°€ ${best_bid}")
            result = await self.client.create_order(is_ask=True, amount=amount, price_ref=best_bid)
            
            if 'success' in result:
                filled = result.get('filled_amount', D('0'))
                avg_price = result.get('avg_price', D('0'))
                self.log(f"[SUCCESS] âœ“ ë§¤ë„ ì²´ê²°: {filled} ETH @ {avg_price:.4f}")
                self.total_volume += filled * avg_price
            else:
                self.log(f"[ERROR] ë§¤ë„ ì‹¤íŒ¨: {result.get('error')}")
                return False
        
        self.is_buy_turn = not self.is_buy_turn
        self.trade_count += 1
        self.session_trades += 1
        
        self.callback('stats', {
            'count': self.trade_count,
            'volume': self.total_volume,
        })
        
        return True
    
    async def update_balance(self):
        """ì”ê³  ì—…ë°ì´íŠ¸"""
        eth, usdc = await self.client.get_balance()
        self.eth_balance = eth
        self.usdc_balance = usdc
        self.callback('balance', {'eth': eth, 'usdc': usdc})
        self.log(f"[INFO] ì”ê³  ì—…ë°ì´íŠ¸: ETH {eth:.4f}, USDC {usdc:.2f}")

    async def countdown(self, seconds: float, prefix: str):
        """ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ"""
        remaining = seconds
        while remaining > 0 and self.running:
            self.callback('status', f"{prefix} {int(remaining)}ì´ˆ")
            await asyncio.sleep(min(1, remaining))
            remaining -= 1
    
    async def _run(self):
        await self.init()
        await self.update_balance()
        
        while self.running:
            # íœ´ì‹ ì²´í¬
            if self.session_trades >= self.trades_before_rest:
                rest_time = self.get_random_rest()
                rest_min = rest_time / 60
                
                self.log(f"[REST] íœ´ì‹ ì‹œì‘: {rest_min:.0f}ë¶„")
                await self.countdown(rest_time, "íœ´ì‹ ì¤‘:")
                
                self.session_trades = 0
                self.log(f"[REST] íœ´ì‹ ë, ì¬ê°œ")
                
                if not self.running:
                    break
            
            # ì”ê³  ì—…ë°ì´íŠ¸ (ê±°ë˜ ì „ ì”ê³  ì¬í™•ì¸)
            await self.update_balance()
            
            # ê±°ë˜ ì‹¤í–‰
            success = await self.execute_trade()
            
            # API ì¿¨ë‹¤ìš´ ì ìš©
            wait_for = self.get_random_interval()
            if not success:
                # ê±°ë˜ ì‹¤íŒ¨ ì‹œ ëŒ€ê¸° ì‹œê°„ì„ ëŠ˜ë¦½ë‹ˆë‹¤.
                wait_for = max(wait_for / 2, 5.0) 
            
            self.log(f"[WAIT] ë‹¤ìŒ ë£¨í”„ê¹Œì§€ {wait_for:.0f}ì´ˆ")
            await self.countdown(wait_for, "ëŒ€ê¸° ì¤‘:")
        
        await self.close()
        self.log("[INFO] ë´‡ ì¤‘ì§€ë¨")
        self.callback('status', "ì¤‘ì§€ë¨")
    
    def start(self):
        if self.running:
            return
        self.running = True
        
        # ğŸš¨ Windows í™˜ê²½ì—ì„œ asyncioì™€ threading ì¶©ëŒ ë°©ì§€ ì •ì±… ì ìš©
        def run_async_loop():
            if os.name == 'nt':
                try:
                    policy = asyncio.WindowsSelectorEventLoopPolicy()
                    asyncio.set_event_loop_policy(policy)
                except AttributeError:
                    pass
            
            try:
                asyncio.run(self._run())
            except RuntimeError as e:
                if 'cannot run' in str(e):
                    self.log(f"[ERROR] ë¹„ë™ê¸° ë£¨í”„ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
                else:
                    raise

        threading.Thread(target=run_async_loop, daemon=True).start()
        self.log("[INFO] ë´‡ ë¡œì§ ìŠ¤ë ˆë“œ ì‹œì‘")
    
    def stop(self):
        self.running = False


class VolumeGUI:
    """ê±°ë˜ëŸ‰ ë´‡ GUI"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Lighter ê±°ë˜ëŸ‰ ë´‡ v2.5 (ìµœì¢… ì•ˆì •í™”)")
        self.root.geometry("700x650")
        self.root.configure(bg='#1a1a2e')
        
        self.bot: Optional[VolumeBot] = None
        self.create_widgets()
        
    def create_widgets(self):
        # ===== ìƒíƒœ =====
        status_frame = tk.Frame(self.root, bg='#1a1a2e')
        status_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # ì”ê³ 
        balance_box = tk.LabelFrame(status_frame, text="ì”ê³ ",
                                     font=('Arial', 10, 'bold'), bg='#16213e', fg='white')
        balance_box.pack(side=tk.LEFT, expand=True, fill=tk.BOTH, padx=5)
        
        self.lbl_eth = tk.Label(balance_box, text="ETH: 0.0000",
                                 font=('Consolas', 12), bg='#16213e', fg='#00ff88')
        self.lbl_eth.pack(side=tk.LEFT, padx=20, pady=10)
        
        self.lbl_usdc = tk.Label(balance_box, text="USDC: $0.00",
                                  font=('Consolas', 12), bg='#16213e', fg='#00ff88')
        self.lbl_usdc.pack(side=tk.LEFT, padx=20, pady=10)
        
        # í†µê³„
        stats_box = tk.LabelFrame(status_frame, text="í†µê³„",
                                   font=('Arial', 10, 'bold'), bg='#16213e', fg='white')
        stats_box.pack(side=tk.LEFT, expand=True, fill=tk.BOTH, padx=5)
        
        self.lbl_trades = tk.Label(stats_box, text="ê±°ë˜: 0íšŒ",
                                    font=('Consolas', 12), bg='#16213e', fg='yellow')
        self.lbl_trades.pack(side=tk.LEFT, padx=20, pady=10)
        
        self.lbl_volume = tk.Label(stats_box, text="ë³¼ë¥¨: $0.00",
                                    font=('Consolas', 12), bg='#16213e', fg='yellow')
        self.lbl_volume.pack(side=tk.LEFT, padx=20, pady=10)
        
        # ===== í˜„ì¬ ìƒíƒœ =====
        self.lbl_status = tk.Label(self.root, text="â— ëŒ€ê¸° ì¤‘",
                                    font=('Arial', 14, 'bold'), bg='#1a1a2e', fg='gray')
        self.lbl_status.pack(pady=10)
        
        # ===== ì„¤ì • =====
        settings_frame = tk.LabelFrame(self.root, text="ì„¤ì •",
                                        font=('Arial', 10, 'bold'), bg='#16213e', fg='white')
        settings_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # ìˆ˜ëŸ‰ ì„¤ì •
        row1 = tk.Frame(settings_frame, bg='#16213e')
        row1.pack(fill=tk.X, padx=10, pady=8)
        
        tk.Label(row1, text="ìˆ˜ëŸ‰ (ETH):", bg='#16213e', fg='white', width=12, anchor='e').pack(side=tk.LEFT)
        tk.Label(row1, text="ìµœì†Œ", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=(10,2))
        self.entry_min_amount = tk.Entry(row1, width=8, font=('Consolas', 10))
        self.entry_min_amount.insert(0, "0.005")
        self.entry_min_amount.pack(side=tk.LEFT)
        
        tk.Label(row1, text="~ ìµœëŒ€", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=(10,2))
        self.entry_max_amount = tk.Entry(row1, width=8, font=('Consolas', 10))
        self.entry_max_amount.insert(0, "0.015")
        self.entry_max_amount.pack(side=tk.LEFT)
        
        # ê°„ê²© ì„¤ì •
        row2 = tk.Frame(settings_frame, bg='#16213e')
        row2.pack(fill=tk.X, padx=10, pady=8)
        
        tk.Label(row2, text="ê°„ê²© (ì´ˆ):", bg='#16213e', fg='white', width=12, anchor='e').pack(side=tk.LEFT)
        tk.Label(row2, text="ìµœì†Œ", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=(10,2))
        self.entry_min_interval = tk.Entry(row2, width=8, font=('Consolas', 10))
        self.entry_min_interval.insert(0, "30")
        self.entry_min_interval.pack(side=tk.LEFT)
        
        tk.Label(row2, text="~ ìµœëŒ€", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=(10,2))
        self.entry_max_interval = tk.Entry(row2, width=8, font=('Consolas', 10))
        self.entry_max_interval.insert(0, "180")
        self.entry_max_interval.pack(side=tk.LEFT)
        
        # íœ´ì‹ ì„¤ì •
        row3 = tk.Frame(settings_frame, bg='#16213e')
        row3.pack(fill=tk.X, padx=10, pady=8)
        
        tk.Label(row3, text="íœ´ì‹:", bg='#16213e', fg='white', width=12, anchor='e').pack(side=tk.LEFT)
        self.entry_trades_before_rest = tk.Entry(row3, width=5, font=('Consolas', 10))
        self.entry_trades_before_rest.insert(0, "15")
        self.entry_trades_before_rest.pack(side=tk.LEFT, padx=(10,2))
        tk.Label(row3, text="íšŒ ê±°ë˜ í›„", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=(2,10))
        
        self.entry_rest_min = tk.Entry(row3, width=5, font=('Consolas', 10))
        self.entry_rest_min.insert(0, "30")
        self.entry_rest_min.pack(side=tk.LEFT)
        tk.Label(row3, text="~", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=2)
        self.entry_rest_max = tk.Entry(row3, width=5, font=('Consolas', 10))
        self.entry_rest_max.insert(0, "60")
        self.entry_rest_max.pack(side=tk.LEFT)
        tk.Label(row3, text="ë¶„ íœ´ì‹", bg='#16213e', fg='gray').pack(side=tk.LEFT, padx=2)
        
        # ===== ë²„íŠ¼ =====
        btn_frame = tk.Frame(self.root, bg='#1a1a2e')
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.btn_start = tk.Button(btn_frame, text="â–¶ ì‹œì‘", command=self.start_bot,
                                    font=('Arial', 12, 'bold'), bg='#4CAF50', fg='white', width=15)
        self.btn_start.pack(side=tk.LEFT, padx=10)
        
        self.btn_stop = tk.Button(btn_frame, text="â–  ì¤‘ë‹¨", command=self.stop_bot,
                                   font=('Arial', 12, 'bold'), bg='#f44336', fg='white', width=15, state=tk.DISABLED)
        self.btn_stop.pack(side=tk.LEFT, padx=10)
        
        tk.Button(btn_frame, text="ğŸ—‘ ë¡œê·¸ ì§€ìš°ê¸°", command=self.clear_log,
                  font=('Arial', 10), bg='#607D8B', fg='white', width=12).pack(side=tk.RIGHT, padx=10)
        
        # ===== ë¡œê·¸ =====
        log_frame = tk.LabelFrame(self.root, text="ë¡œê·¸",
                                   font=('Arial', 10, 'bold'), bg='#16213e', fg='white')
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=15,
                                                   font=('Consolas', 9), bg='#0f0f23', fg='#00ff88')
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.log_text.tag_config('SUCCESS', foreground='#00ff88')
        self.log_text.tag_config('ERROR', foreground='#ff6b6b')
        self.log_text.tag_config('BUY', foreground='#00bfff')
        self.log_text.tag_config('SELL', foreground='#ff9800')
        self.log_text.tag_config('REST', foreground='#9c27b0')
        self.log_text.tag_config('WAIT', foreground='gray')
        self.log_text.tag_config('INFO', foreground='gray')
        
    def log(self, msg):
        ts = datetime.now().strftime("%H:%M:%S")
        
        tag = None
        if '[SUCCESS]' in msg:
            tag = 'SUCCESS'
        elif '[ERROR]' in msg:
            tag = 'ERROR'
        elif '[BUY]' in msg:
            tag = 'BUY'
        elif '[SELL]' in msg:
            tag = 'SELL'
        elif '[REST]' in msg:
            tag = 'REST'
        elif '[WAIT]' in msg:
            tag = 'WAIT'
        elif '[INFO]' in msg:
            tag = 'INFO'
        
        self.log_text.insert(tk.END, f"[{ts}] {msg}\n", tag)
        self.log_text.see(tk.END)
        
    def callback(self, event, data):
        if event == 'log':
            self.root.after(0, lambda: self.log(data))
        elif event == 'balance':
            self.root.after(0, lambda: self.update_balance(data))
        elif event == 'stats':
            self.root.after(0, lambda: self.update_stats(data))
        elif event == 'status':
            self.root.after(0, lambda: self.update_status(data))
    
    def update_balance(self, data):
        self.lbl_eth.config(text=f"ETH: {data['eth']:.4f}")
        self.lbl_usdc.config(text=f"USDC: ${data['usdc']:,.2f}")
    
    def update_stats(self, data):
        self.lbl_trades.config(text=f"ê±°ë˜: {data['count']}íšŒ")
        self.lbl_volume.config(text=f"ë³¼ë¥¨: ${data['volume']:,.2f}")
    
    def update_status(self, status):
        if "íœ´ì‹" in status:
            self.lbl_status.config(text=f"ğŸ’¤ {status}", fg='#9c27b0')
        elif "ëŒ€ê¸°" in status:
            self.lbl_status.config(text=f"â³ {status}", fg='yellow')
        elif "ì¤‘ì§€" in status:
            self.lbl_status.config(text=f"â— {status}", fg='gray')
        elif "ì‹¤í–‰ ì¤‘" in status:
            self.lbl_status.config(text=f"â— {status}", fg='#00ff88')
        else:
            self.lbl_status.config(text=f"â— {status}", fg='gray')
    
    def start_bot(self):
        if not LIGHTER_API_KEY:
            messagebox.showerror("Error", "API Keyë¥¼ ì½”ë“œ ìƒë‹¨ì— ì…ë ¥í•˜ì„¸ìš”!")
            return
        
        try:
            # ì„¤ì • ê°’ ìœ íš¨ì„± ê²€ì‚¬ ë° Decimal ë³€í™˜
            min_amount = D(self.entry_min_amount.get())
            max_amount = D(self.entry_max_amount.get())
            min_interval = float(self.entry_min_interval.get())
            max_interval = float(self.entry_max_interval.get())
            trades_before_rest = int(self.entry_trades_before_rest.get())
            rest_min = float(self.entry_rest_min.get())
            rest_max = float(self.entry_rest_max.get())
            
            if min_amount <= 0 or min_interval <= 0 or trades_before_rest <= 0:
                 raise ValueError("ì„¤ì • ê°’ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.")

        except Exception as e:
            messagebox.showerror("ì„¤ì • ì˜¤ë¥˜", f"ì…ë ¥ ê°’ì„ í™•ì¸í•˜ì„¸ìš”: {e}")
            return

        self.bot = VolumeBot(self.callback)
        
        # ì„¤ì • ì ìš©
        self.bot.min_amount = min_amount
        self.bot.max_amount = max_amount
        self.bot.min_interval = min_interval
        self.bot.max_interval = max_interval
        self.bot.trades_before_rest = trades_before_rest
        self.bot.rest_min = rest_min
        self.bot.rest_max = rest_max
        
        self.bot.start()
        
        self.btn_start.config(state=tk.DISABLED)
        self.btn_stop.config(state=tk.NORMAL)
        self.update_status("ì‹¤í–‰ ì¤‘")
        self.log("[INFO] ë´‡ ì‹œì‘")
    
    def stop_bot(self):
        if self.bot:
            self.bot.stop()
        self.btn_start.config(state=tk.NORMAL)
        self.btn_stop.config(state=tk.DISABLED)
    
    def clear_log(self):
        self.log_text.delete(1.0, tk.END)
    
    def run(self):
        self.log("=" * 45)
        self.log("[INFO] Lighter ê±°ë˜ëŸ‰ ë´‡ v2.5 (ìµœì¢… ì•ˆì •í™”)")
        self.log("=" * 45)
        self.log("[INFO] ğŸš€ ëª¨ë“  ì˜¤ë¥˜ í•´ê²° ì™„ë£Œ: SDK ì‘ë‹µê¹Œì§€ ë°©ì–´")
        self.log("")
        self.root.mainloop()


if __name__ == "__main__":
    app = VolumeGUI()
    app.run()
