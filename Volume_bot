# volume_bot.py (Lighter Volume Bot - ìµœì¢… ìˆ˜ì • ë²„ì „)
# Python 3.11 í˜¸í™˜, asyncio + tkinter GUI
# - LIGHTER SDK ë™ê¸° í˜¸ì¶œì„ asyncio.to_threadë¡œ ë¹„ë™ê¸° í™˜ê²½ì— í†µí•©
# - ì£¼ë¬¸ ì‹¤íŒ¨ ë°©ì§€ ìœ„í•´ TimeInForce=IOC ì„¤ì •
# - GUI ì”ì•¡ ì—…ë°ì´íŠ¸ ë¡œì§ ì¶”ê°€
# - ëª¨ë“  ë“¤ì—¬ì“°ê¸°(Indentation) ì •ë¦¬ ì™„ë£Œ

import tkinter as tk
from tkinter import scrolledtext, messagebox
import threading
import asyncio
import time
import random
from decimal import Decimal, ROUND_DOWN
from datetime import datetime
from typing import Optional
import os 
import aiohttp
# lighter SDK import (ì‹¤í–‰ ì‹œ í•„ìš”)
try:
    import lighter
except ImportError:
    print("ê²½ê³ : 'lighter' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. pip install lighter ë¡œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”.")
    lighter = None


# ------------------ ì‚¬ìš©ì ì„¤ì • (ì—¬ê¸°ë§Œ ìˆ˜ì •) ------------------
# ğŸ’¡ ë³´ì•ˆ ê¶Œê³ : ì‹¤ì œ ìš´ì˜ì‹œ í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.
LIGHTER_API_KEY = "ë³¸ì¸í‚¤ì…ë ¥"          # ì‹¤ì œ ìš´ì˜ì‹œ ì—¬ê¸°ì— í‚¤ ë„£ê¸° (ë¬¸ìì—´)
LIGHTER_ACCOUNT_INDEX = 1                 # ğŸš¨ ì´ì „ ë¡œê·¸ì—ì„œ í™•ì¸ëœ ìœ íš¨í•œ ì¸ë±ìŠ¤ ì‚¬ìš©
LIGHTER_API_KEY_INDEX = 0

TEST_MODE = False                     # True: Mock(ê¶Œì¥ í…ŒìŠ¤íŠ¸). False: ì‹¤ê±°ë˜ (ì£¼ì˜!)
MIN_ORDER_SIZE = Decimal("0.005")     # ìµœì†Œ ì£¼ë¬¸ ìˆ˜ëŸ‰ (ETH)
SLIPPAGE_PCT = Decimal("0.01")        # 1% ê¸°ë³¸ ìŠ¬ë¦¬í”¼ì§€ (IOC ì£¼ë¬¸ ì‹œ ì¦‰ì‹œ ì²´ê²° ìœ ë„)
BALANCE_POLL_EVERY = 3                # ì”ê³  ì¡°íšŒëŠ” íŠ¸ë ˆì´ë“œ ë£¨í”„ì—ì„œ NíšŒë§ˆë‹¤ 1íšŒ
API_COOLDOWN = 1.5                    # ë£¨í”„ ê¸°ë³¸ ì¿¨ë‹¤ìš´(ì´ˆ)
MAX_RETRIES = 3                       # ì—ëŸ¬ ë³µêµ¬ ì¬ì‹œë„ íšŸìˆ˜
LOG_FILE = "volume_bot.log"
MARKET_INDEX = 2048                   # ETH/USDC ë§ˆì¼“ (í•„ìš”ì‹œ ë³€ê²½)
# ----------------------------------------------------------------

# ì•ˆì „ íƒ€ì… ë˜í¼
def D(x):
    return Decimal(str(x))

# ë¡œê±° (íŒŒì¼ + GUI ì½œë°±)
class Logger:
    def __init__(self, gui_callback=None, path=LOG_FILE):
        self.gui_callback = gui_callback
        self.path = path
        try:
            open(self.path, "a").close()
        except Exception:
            pass

    def _ts(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def log(self, msg):
        line = f"[{self._ts()}] {msg}"
        if self.gui_callback:
            try:
                # GUI ì—…ë°ì´íŠ¸ëŠ” ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
                self.gui_callback('log', line)
            except Exception:
                pass
        print(line)
        try:
            with open(self.path, "a", encoding="utf-8") as f:
                f.write(line + "\n")
        except Exception:
            pass

# ------------------ Lighter client wrapper ------------------
class LighterClient:
    def __init__(self, logger: Logger):
        self.base_url = "https://mainnet.zklighter.elliot.ai/api/v1"
        self.logger = logger
        self.signer = None
        self.session = None
        self.order_counter = 0

    async def init(self):
        # aiohttp session ìƒì„±
        self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10))
        
        # signer ì´ˆê¸°í™” ì‹œë„
        if LIGHTER_API_KEY and not TEST_MODE and lighter:
            try:
                # SignerClientëŠ” ë™ê¸° ê°ì²´ì…ë‹ˆë‹¤.
                self.signer = lighter.SignerClient(
                    url="https://mainnet.zklighter.elliot.ai",
                    account_index=LIGHTER_ACCOUNT_INDEX,
                    api_private_keys={LIGHTER_API_KEY_INDEX: LIGHTER_API_KEY},
                )
                self.logger.log("[SUCCESS] âœ“ Lighter SDK ì—°ê²°")
            except Exception as e:
                self.logger.log(f"[ERROR] Lighter SDK ì—°ê²° ì‹¤íŒ¨: {e}")
                self.signer = None
        else:
            self.logger.log("[INFO] LighterClient: TEST_MODE ë˜ëŠ” API í‚¤ ì—†ìŒ - signer ë¯¸ì‚¬ìš©")

    async def close(self):
        if self.session and not self.session.closed:
            await self.session.close()

    def _next_order_id(self):
        self.order_counter += 1
        return int(time.time() * 1000) % (2**31) + self.order_counter

    async def create_order(self, is_ask: bool, base_amount: int, price_int: int):
        if not self.signer:
            return {'error': 'No signer'}
        
        try:
            # ğŸ’¡ í•µì‹¬ ìˆ˜ì •: ë™ê¸° í•¨ìˆ˜ì¸ self.signer.create_orderë¥¼ asyncio.to_threadë¡œ ë˜í•‘í•˜ì—¬ ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì‹¤í–‰
            res = await asyncio.to_thread(
                self.signer.create_order,
                market_index=MARKET_INDEX,
                client_order_index=self._next_order_id(),
                base_amount=base_amount,
                price=price_int,
                is_ask=is_ask,
                order_type=0,           
                time_in_force=1,        # ğŸ’¡ IOC (Immediate-Or-Cancel)ë¡œ ì„¤ì •í•˜ì—¬ ë¯¸ì²´ê²° ë°©ì§€
                reduce_only=False,
                order_expiry=0,
            )
            # resëŠ” ì´ë¯¸ ë™ê¸° í•¨ìˆ˜ ì‹¤í–‰ ê²°ê³¼
            return {'response': res}
        except Exception as e:
            return {'error': str(e)}

# ------------------ Volume Bot (ì‹¤ê±°ë˜/ëª¨ì˜ ê³µí†µ ë¡œì§) ------------------
class VolumeBot:
    def __init__(self, callback):
        self.callback = callback
        self.logger = Logger(gui_callback=callback)
        self.client: Optional[LighterClient] = None
        self.running = False

        # ì„¤ì • (GUIì—ì„œë„ ë…¸ì¶œ ê°€ëŠ¥)
        self.min_amount = D("0.005")
        self.max_amount = D("0.015")
        self.min_interval = 30
        self.max_interval = 180
        self.trades_before_rest = 15
        self.rest_min = 30
        self.rest_max = 60
        self.slippage_pct = SLIPPAGE_PCT
        self.min_order_size = MIN_ORDER_SIZE

        # ìƒíƒœ
        self.trade_count = 0
        self.session_trades = 0
        self.total_volume = D("0")
        self.is_buy_turn = True
        self.current_amount = D("0")
        self.eth_balance = D("0")
        self.usdc_balance = D("0")

        # control
        self._balance_poll_counter = 0
        self._backoff_seconds = 0

    def log(self, msg):
        self.logger.log(msg)

    async def init(self):
        self.client = LighterClient(self.logger)
        await self.client.init()

    async def close(self):
        if self.client:
            await self.client.close()

    def _rand_amount(self):
        a = float(self.min_amount)
        b = float(self.max_amount)
        val = random.uniform(a, b)
        return D(str(val)).quantize(D('0.001'))

    def _rand_interval(self):
        return random.uniform(self.min_interval, self.max_interval)

    def _rand_rest(self):
        return random.uniform(self.rest_min * 60, self.rest_max * 60)

    # ------------------ Mock / real API helpers ------------------
    async def _mock_get_price(self):
        mid = D("2000") + D(str(random.uniform(-5, 5)))
        return (mid - D("0.5"), mid + D("0.5"))

    async def _mock_get_balance(self):
        self.eth_balance = D("0.1")
        self.usdc_balance = D("200.0")
        return (self.eth_balance, self.usdc_balance)

    # price & balance getters (with error handling and backoff)
    async def get_price(self):
        if self._backoff_seconds > 0:
            self.log(f"[BACKOFF] ê°€ê²© ì¡°íšŒ ëŒ€ê¸° ì¤‘: {self._backoff_seconds:.0f}ì´ˆ")
            await asyncio.sleep(self._backoff_seconds)
            self._backoff_seconds = 0

        if TEST_MODE:
            return await self._mock_get_price()

        try:
            async with self.client.session.get(f"{self.client.base_url}/orderBookOrders",
                                                params={'market_id': str(MARKET_INDEX), 'limit': '1'}) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    bids = data.get('bids', [])
                    asks = data.get('asks', [])
                    best_bid = D("0")
                    best_ask = D("0")
                    if bids:
                        best_bid = D(str(bids[0].get('price', '0')))
                    if asks:
                        best_ask = D(str(asks[0].get('price', '0')))
                    return best_bid, best_ask
                elif resp.status == 429:
                    self.logger.log("[ERROR] HTTP 429 /orderBookOrders - ë°±ì˜¤í”„ ì ìš©")
                    self._backoff_seconds = min(30, (self._backoff_seconds or API_COOLDOWN) * 2)
                    return D("0"), D("0")
                else:
                    self.logger.log(f"[ERROR] HTTP {resp.status} /orderBookOrders")
                    return D("0"), D("0")
        except Exception as e:
            self.logger.log(f"[ERROR] ê°€ê²© ì¡°íšŒ ì˜ˆì™¸: {e}")
            return D("0"), D("0")

    async def get_balance(self):
        if TEST_MODE:
            return await self._mock_get_balance()
        
        try:
            async with self.client.session.get(f"{self.client.base_url}/account",
                                                params={'by': 'index', 'value': str(LIGHTER_ACCOUNT_INDEX)}) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    eth = D("0")
                    usdc = D("0")
                    accounts = data.get('accounts', [])
                    if accounts:
                        assets = accounts[0].get('assets', [])
                        for asset in assets:
                            if asset.get('symbol') == 'ETH':
                                eth = D(str(asset.get('balance', '0')))
                            elif asset.get('symbol') == 'USDC':
                                usdc = D(str(asset.get('balance', '0')))
                    
                    self.eth_balance = eth
                    self.usdc_balance = usdc

                    # ğŸ’¡ GUI ì”ì•¡ ì—…ë°ì´íŠ¸ (ìˆ˜ì • ì‚¬í•­)
                    try:
                        self.callback('balance', {'eth': float(eth), 'usdc': float(usdc)})
                    except Exception as e:
                        self.logger.log(f"[ERROR] GUI ì”ì•¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")

                    return eth, usdc
                elif resp.status == 429:
                    self.logger.log("[ERROR] HTTP 429 /account - ë°±ì˜¤í”„ ì ìš©")
                    self._backoff_seconds = min(30, (self._backoff_seconds or API_COOLDOWN) * 2)
                    return D("0"), D("0")
                else:
                    self.logger.log(f"[ERROR] HTTP {resp.status} /account")
                    return D("0"), D("0")
        except Exception as e:
            self.logger.log(f"[ERROR] ì”ê³  ì¡°íšŒ ì˜ˆì™¸: {e}")
            return D("0"), D("0")


    # order send wrapper with retries and fill parsing
    async def _send_order(self, is_sell: bool, amount: Decimal, price_ref: Decimal):
        try:
            # Lighterì˜ Atomic Unit ë³€í™˜ (ETH: 10^4, Price: 100)
            base_amount = int((amount * D(10**4)).to_integral_value(rounding=ROUND_DOWN))
            tick = D("0.01")
            
            # ìŠ¬ë¦¬í”¼ì§€ ì ìš©í•˜ì—¬ ì¦‰ì‹œ ì²´ê²° ìœ ë„
            if is_sell:
                # ë§¤ë„: ë‚®ì€ ê°€ê²©ì— ì£¼ë¬¸ (ìµœê³  ë§¤ìˆ˜í˜¸ê°€ - ìŠ¬ë¦¬í”¼ì§€)
                price_with_slippage = price_ref - max(price_ref * self.slippage_pct, tick)
            else:
                # ë§¤ìˆ˜: ë†’ì€ ê°€ê²©ì— ì£¼ë¬¸ (ìµœì € ë§¤ë„í˜¸ê°€ + ìŠ¬ë¦¬í”¼ì§€)
                price_with_slippage = price_ref + max(price_ref * self.slippage_pct, tick)
            
            price_int = int((price_with_slippage * D(100)).to_integral_value(rounding=ROUND_DOWN))
        except Exception as e:
            return {'error': f'Order parameter conversion error: {e}'}

        # TEST mode: fake fill
        if TEST_MODE:
            filled = amount * D(str(random.uniform(0.9, 1.0)))
            avg_price = (price_with_slippage if 'price_with_slippage' in locals() else price_ref).quantize(D('0.0001'))
            return {'success': True, 'filled_amount': filled, 'avg_price': avg_price, 'response': {'mock': True}}

        # real send with retries
        attempt = 0
        backoff = 1.0
        while attempt < MAX_RETRIES:
            attempt += 1
            resp = await self.client.create_order(is_ask=is_sell, base_amount=base_amount, price_int=price_int)
            
            if 'error' in resp:
                err = resp['error']
                if '429' in str(err) or 'Too Many Requests' in str(err):
                    self.logger.log(f"[ERROR] ì£¼ë¬¸ 429 ì‘ë‹µ, ë°±ì˜¤í”„ ì ìš©: {backoff:.1f}ì´ˆ")
                    await asyncio.sleep(backoff)
                    backoff = min(10.0, backoff * 2)
                    continue
                else:
                    self.logger.log(f"[ERROR] ì£¼ë¬¸ ì˜¤ë¥˜: {err} (retry {attempt}/{MAX_RETRIES})")
                    await asyncio.sleep(backoff)
                    backoff = min(5.0, backoff * 2)
                    continue
            
            # --- ì£¼ë¬¸ ì„±ê³µ ë° ì²´ê²° ê²°ê³¼ íŒŒì‹± ---
            r = resp.get('response', {})
            filled_amount = D("0")
            avg_price = D("0")

            try:
                # 1. 'fills' ë¦¬ìŠ¤íŠ¸ íŒŒì‹± ì‹œë„ (ê°€ì¥ ì •í™•í•œ ì •ë³´)
                fills = r.get('fills') or r.get('filled') or []
                if isinstance(fills, list) and fills:
                    total_base = D("0")
                    total_quote = D("0")
                    for f in fills:
                        ba = D(str(f.get('filled_base_amount', f.get('base_amount', 0))))
                        pa = D(str(f.get('price', f.get('avg_price', 0))))
                        total_base += ba
                        total_quote += ba * pa
                    if total_base > 0:
                        filled_amount = total_base
                        avg_price = (total_quote / total_base).quantize(D('0.0001'))
                
                # 2. ê°œë³„ í•„ë“œ íŒŒì‹± ì‹œë„ (Fallback)
                if filled_amount == 0:
                    fa = r.get('filled_base_amount') or r.get('filledAmount') or r.get('filled_amount')
                    ap = r.get('avg_price') or r.get('avgPrice') or r.get('avg')
                    if fa:
                        filled_amount = D(str(fa))
                    if ap:
                        avg_price = D(str(ap))

            except Exception as e:
                self.logger.log(f"[WARN] ì²´ê²° ì •ë³´ íŒŒì‹± ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")
                pass # ìµœì„ ì„ ë‹¤í•´ íŒŒì‹± í›„ ì§„í–‰

            # IOC ì£¼ë¬¸(time_in_force=1)ì˜ ê²½ìš°, ì²´ê²°ì´ ì•ˆ ë˜ë©´ ì„œë²„ê°€ ì‘ë‹µì—ì„œ 0ìœ¼ë¡œ ë°˜í™˜í•  ìˆ˜ ìˆìŒ.
            # í•˜ì§€ë§Œ ë´‡ì€ ë³¼ë¥¨ ìƒì„±ì´ ëª©ì ì´ë¯€ë¡œ, ì²´ê²°ì´ 0ì´ë¼ë©´ ì£¼ë¬¸ì´ ì·¨ì†Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼í•˜ê³  ì‹¤íŒ¨ ì²˜ë¦¬í•¨.
            if filled_amount == 0:
                # ğŸ’¡ IOC ì£¼ë¬¸ì¸ë° fillì´ 0ì´ë©´, ì”ê³  ë¶€ì¡±ì´ë‚˜ í˜¸ê°€ ì°¨ì´ë¡œ ì¸í•´ ì¦‰ì‹œ ì·¨ì†Œëœ ê²ƒì…ë‹ˆë‹¤.
                return {'error': 'Order cancelled (0 fill from IOC)', 'response': r}

            return {'success': True, 'filled_amount': filled_amount, 'avg_price': avg_price, 'response': r}

        return {'error': 'Max retries exceeded'}

    # main trade execution (one buy or sell step)
    async def execute_trade(self):
        # get price
        best_bid, best_ask = await self.get_price()
        if best_bid == 0 or best_ask == 0:
            self.log("[ERROR] ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨")
            return False

        if self.is_buy_turn:
            self.current_amount = self._rand_amount()
            amount = self.current_amount
            # ë§¤ìˆ˜ ì‹œ USDC ì”ê³  í™•ì¸ ë¡œì§ ì¶”ê°€ í•„ìš” (í˜„ì¬ëŠ” ETH ì”ê³ ë§Œ í™•ì¸)
            if amount * best_ask > self.usdc_balance:
                 self.log(f"[ERROR] USDC ì”ê³  ë¶€ì¡±: {self.usdc_balance:.2f} USDC")
                 # ì”ê³  ë¶€ì¡± ì‹œ ë‹¤ìŒ í„´ì„ ìŠ¤í‚µí•˜ê³  ë‹¤ì‹œ ì”ê³  ì²´í¬ ë° ë°˜ëŒ€ë§¤ë§¤ ìœ ë„
                 return False

            if amount < self.min_order_size:
                self.log(f"[ERROR] ì£¼ë¬¸ ìˆ˜ëŸ‰ì´ ìµœì†Œê°’ ë¯¸ë§Œ: {amount}")
                return False
            
            self.log(f"[BUY] ì‹œë„ {amount} ETH @ í˜¸ê°€ {best_ask} (ìŠ¬ë¦¬í”¼ì§€ ì ìš©)")
            res = await self._send_order(False, amount, best_ask)
            
            if res.get('success'):
                filled = res.get('filled_amount', D('0'))
                avg_price = res.get('avg_price', D('0'))
                self.total_volume += (filled * avg_price)
                self.log(f"[SUCCESS] ë§¤ìˆ˜ ì²´ê²°: {filled} ETH @ {avg_price:.4f}")
            else:
                self.log(f"[ERROR] ë§¤ìˆ˜ ì‹¤íŒ¨: {res.get('error')}")
                return False
        else:
            # sell: check balance
            # ë§¤ë„ ì‹œì—ëŠ” ETH ì”ê³  í™•ì¸
            amount = min(self.current_amount, self.eth_balance).quantize(D('0.0001'), ROUND_DOWN)
            if amount < self.min_order_size:
                self.log(f"[ERROR] ETH ì”ê³  ë¶€ì¡±: {self.eth_balance:.4f} ETH")
                # ì”ê³  ë¶€ì¡± ì‹œ ë‹¤ìŒ í„´ì„ ìŠ¤í‚µí•˜ê³  ë‹¤ì‹œ ì”ê³  ì²´í¬ ë° ë°˜ëŒ€ë§¤ë§¤ ìœ ë„
                return False
                
            self.log(f"[SELL] ì‹œë„ {amount} ETH @ í˜¸ê°€ {best_bid} (ìŠ¬ë¦¬í”¼ì§€ ì ìš©)")
            res = await self._send_order(True, amount, best_bid)
            
            if res.get('success'):
                filled = res.get('filled_amount', D('0'))
                avg_price = res.get('avg_price', D('0'))
                self.total_volume += (filled * avg_price)
                self.log(f"[SUCCESS] ë§¤ë„ ì²´ê²°: {filled} ETH @ {avg_price:.4f}")
            else:
                self.log(f"[ERROR] ë§¤ë„ ì‹¤íŒ¨: {res.get('error')}")
                return False

        # toggle turn
        self.is_buy_turn = not self.is_buy_turn
        self.trade_count += 1
        self.session_trades += 1
        
        # emit stats
        try:
            self.callback('stats', {'count': self.trade_count, 'volume': float(self.total_volume)})
        except Exception:
            pass
        return True

    # ------------------ main loop ------------------
    async def _run(self):
        await self.init()
        # ì´ˆê¸° ì”ê³  ì¡°íšŒ
        eth_start, usdc_start = await self.get_balance()
        if eth_start == 0 and usdc_start == 0 and not TEST_MODE:
            self.log("[CRITICAL] ì”ê³ ê°€ 0ì…ë‹ˆë‹¤. íŠ¸ë ˆì´ë”©ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.")
            self.running = False
            await self.close()
            return

        while self.running:
            # íœ´ì‹ ì²´í¬
            if self.session_trades >= self.trades_before_rest:
                rest_time = self._rand_rest()
                rest_min = rest_time / 60
                self.log(f"[REST] íœ´ì‹ ì‹œì‘: {rest_min:.0f}ë¶„")
                await asyncio.sleep(rest_time)
                self.session_trades = 0
                self.log("[REST] íœ´ì‹ ë, ì¬ê°œ")

            # ì”ê³  í´ë§
            if self._balance_poll_counter % BALANCE_POLL_EVERY == 0:
                await self.get_balance()
            self._balance_poll_counter += 1

            # íŠ¸ë ˆì´ë“œ ì‹¤í–‰
            success = await self.execute_trade()

            # ì¿¨ë‹¤ìš´ ì ìš©
            wait_for = API_COOLDOWN
            if not success:
                wait_for = max(wait_for, 2.0)
            wait_for += random.uniform(0, 0.5)
            self.log(f"[WAIT] ë‹¤ìŒ ë£¨í”„ê¹Œì§€ {wait_for:.1f}ì´ˆ")
            await asyncio.sleep(wait_for)

        await self.close()
        self.log("[INFO] ë´‡ ì¤‘ì§€ë¨")
        try:
            self.callback('status', "ì¤‘ì§€ë¨")
        except Exception:
            pass

    def start(self):
        if self.running:
            return
        self.running = True
        # run loop on separate thread with asyncio
        # Windowsì—ì„œ asyncioë¥¼ ìœ„í•´ ì •ì±… ì„¤ì • (í•„ìš”í•œ ê²½ìš°)
        if os.name == 'nt':
            try:
                policy = asyncio.WindowsSelectorEventLoopPolicy()
                asyncio.set_event_loop_policy(policy)
            except AttributeError:
                pass

        threading.Thread(target=lambda: asyncio.run(self._run()), daemon=True).start()

    def stop(self):
        self.running = False

# ------------------ GUI ------------------
class VolumeGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title(f"Lighter Volume Bot v2 ({'TEST' if TEST_MODE else 'LIVE'})")
        self.root.geometry("760x620")
        self.bot: Optional[VolumeBot] = None
        self.create_widgets()
        
    def create_widgets(self):
        # Status / balances / stats
        top = tk.Frame(self.root)
        top.pack(fill=tk.X, padx=8, pady=6)
        self.lbl_eth = tk.Label(top, text="ETH: 0.0000", width=18, anchor='w')
        self.lbl_eth.pack(side=tk.LEFT, padx=6)
        self.lbl_usdc = tk.Label(top, text="USDC: $0.00", width=18, anchor='w')
        self.lbl_usdc.pack(side=tk.LEFT, padx=6)
        self.lbl_trades = tk.Label(top, text="ê±°ë˜: 0íšŒ", width=12, anchor='w')
        self.lbl_trades.pack(side=tk.LEFT, padx=6)
        self.lbl_volume = tk.Label(top, text="ë³¼ë¥¨: $0.00", width=20, anchor='w')
        self.lbl_volume.pack(side=tk.LEFT, padx=6)

        # Control frame
        ctrl = tk.LabelFrame(self.root, text="ì„¤ì •")
        ctrl.pack(fill=tk.X, padx=8, pady=6)

        tk.Label(ctrl, text="ìˆ˜ëŸ‰ ìµœì†Œ").grid(row=0, column=0, padx=6, pady=6)
        self.entry_min_amount = tk.Entry(ctrl, width=10); self.entry_min_amount.insert(0, str(float(D("0.005"))))
        self.entry_min_amount.grid(row=0, column=1, padx=6, pady=6)

        tk.Label(ctrl, text="ìˆ˜ëŸ‰ ìµœëŒ€").grid(row=0, column=2, padx=6, pady=6)
        self.entry_max_amount = tk.Entry(ctrl, width=10); self.entry_max_amount.insert(0, str(float(D("0.015"))))
        self.entry_max_amount.grid(row=0, column=3, padx=6, pady=6)

        tk.Label(ctrl, text="ìŠ¬ë¦¬í”¼ì§€ (%)").grid(row=1, column=0, padx=6, pady=6)
        self.entry_slippage = tk.Entry(ctrl, width=8); self.entry_slippage.insert(0, str(float(SLIPPAGE_PCT * 100)))
        self.entry_slippage.grid(row=1, column=1, padx=6, pady=6)

        tk.Label(ctrl, text="ìµœì†Œì£¼ë¬¸(ETH)").grid(row=1, column=2, padx=6, pady=6)
        self.entry_min_order = tk.Entry(ctrl, width=10); self.entry_min_order.insert(0, str(MIN_ORDER_SIZE))
        self.entry_min_order.grid(row=1, column=3, padx=6, pady=6)

        tk.Label(ctrl, text="ê°„ê²© ìµœì†Œ(ì´ˆ)").grid(row=2, column=0, padx=6, pady=6)
        self.entry_min_interval = tk.Entry(ctrl, width=10); self.entry_min_interval.insert(0, "30")
        self.entry_min_interval.grid(row=2, column=1, padx=6, pady=6)

        tk.Label(ctrl, text="ê°„ê²© ìµœëŒ€(ì´ˆ)").grid(row=2, column=2, padx=6, pady=6)
        self.entry_max_interval = tk.Entry(ctrl, width=10); self.entry_max_interval.insert(0, "180")
        self.entry_max_interval.grid(row=2, column=3, padx=6, pady=6)

        tk.Label(ctrl, text="íŠ¸ë ˆì´ë“œ í›„ íœ´ì‹(NíšŒ)").grid(row=3, column=0, padx=6, pady=6)
        self.entry_trades_before_rest = tk.Entry(ctrl, width=6); self.entry_trades_before_rest.insert(0, "15")
        self.entry_trades_before_rest.grid(row=3, column=1, padx=6, pady=6)

        tk.Label(ctrl, text="íœ´ì‹ ë¶„(min)").grid(row=3, column=2, padx=6, pady=6)
        self.entry_rest_min = tk.Entry(ctrl, width=6); self.entry_rest_min.insert(0, "30")
        self.entry_rest_min.grid(row=3, column=3, padx=6, pady=6)

        tk.Label(ctrl, text="íœ´ì‹ ë¶„(max)").grid(row=3, column=4, padx=6, pady=6)
        self.entry_rest_max = tk.Entry(ctrl, width=6); self.entry_rest_max.insert(0, "60")
        self.entry_rest_max.grid(row=3, column=5, padx=6, pady=6)

        # Start / Stop buttons
        btn_frame = tk.Frame(self.root)
        btn_frame.pack(fill=tk.X, padx=8, pady=6)
        self.btn_start = tk.Button(btn_frame, text="â–¶ ì‹œì‘", bg="#4CAF50", fg="white", command=self.start_bot)
        self.btn_start.pack(side=tk.LEFT, padx=6)
        self.btn_stop = tk.Button(btn_frame, text="â–  ì¤‘ë‹¨", bg="#f44336", fg="white", command=self.stop_bot, state=tk.DISABLED)
        self.btn_stop.pack(side=tk.LEFT, padx=6)
        self.btn_clear = tk.Button(btn_frame, text="ë¡œê·¸ ì§€ìš°ê¸°", command=self.clear_log); self.btn_clear.pack(side=tk.RIGHT, padx=6)
        
        # Log
        log_frame = tk.LabelFrame(self.root, text="ë¡œê·¸")
        log_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=6)
        self.log_text = scrolledtext.ScrolledText(log_frame, height=18)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)


    # GUI callback
    def callback(self, event, data):
        # tkinterëŠ” ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, root.afterë¥¼ ì‚¬ìš©
        if event == 'log':
            self.root.after(0, lambda: self.append_log(data))
        elif event == 'balance':
            self.root.after(0, lambda: self.update_balance_labels(data))
        elif event == 'stats':
            self.root.after(0, lambda: self.update_stats(data))
        elif event == 'status':
            self.root.after(0, lambda: self.update_status(data))

    def append_log(self, line):
        self.log_text.insert(tk.END, line + "\n")
        self.log_text.see(tk.END)

    def update_balance_labels(self, data):
        try:
            self.lbl_eth.config(text=f"ETH: {data['eth']:.4f}")
            self.lbl_usdc.config(text=f"USDC: ${data['usdc']:,.2f}")
        except Exception:
            pass

    def update_stats(self, data):
        try:
            self.lbl_trades.config(text=f"ê±°ë˜: {data['count']}íšŒ")
            self.lbl_volume.config(text=f"ë³¼ë¥¨: ${data['volume']:,.2f}")
        except Exception:
            pass

    def update_status(self, text):
        pass # í˜„ì¬ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠìŒ

    # start/stop
    def start_bot(self):
        try:
            if self.btn_start['state'] == tk.DISABLED:
                return
            
            # instantiate bot
            self.bot = VolumeBot(self.callback)
            
            # apply GUI settings (Decimal ë³€í™˜ ì‹œë„)
            self.bot.min_amount = D(self.entry_min_amount.get())
            self.bot.max_amount = D(self.entry_max_amount.get())
            self.bot.slippage_pct = D(self.entry_slippage.get()) / D(100)
            self.bot.min_order_size = D(self.entry_min_order.get())
            self.bot.min_interval = float(self.entry_min_interval.get())
            self.bot.max_interval = float(self.entry_max_interval.get())
            self.bot.trades_before_rest = int(self.entry_trades_before_rest.get())
            self.bot.rest_min = float(self.entry_rest_min.get())
            self.bot.rest_max = float(self.entry_rest_max.get())

            # Validation
            if self.bot.min_amount >= self.bot.max_amount or self.bot.min_interval >= self.bot.max_interval:
                raise ValueError("ìµœì†Œê°’ì€ ìµœëŒ€ê°’ë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤.")

            # start
            self.bot.start()
            self.btn_start.config(state=tk.DISABLED)
            self.btn_stop.config(state=tk.NORMAL)
            self.append_log("[INFO] ë´‡ ì‹œì‘ (ì„¤ì • ì ìš© ì™„ë£Œ)")
        except Exception as e:
            messagebox.showerror("ì„¤ì •/ì‹œì‘ ì˜¤ë¥˜", str(e))

    def stop_bot(self):
        if self.bot:
            self.bot.stop()
        self.btn_start.config(state=tk.NORMAL)
        self.btn_stop.config(state=tk.DISABLED)
        self.append_log("[INFO] ì¤‘ì§€ ìš”ì²­ë¨")

    def clear_log(self):
        self.log_text.delete(1.0, tk.END)

# ------------------ ì‹¤í–‰ ------------------
if __name__ == "__main__":
    if lighter is None and not TEST_MODE:
        print("\nFATAL: Lighter SDKê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•„ ì‹¤ê±°ë˜ ëª¨ë“œ(TEST_MODE=False)ë¥¼ ì‹¤í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n")
    
    app = VolumeGUI()
    app.root.mainloop()
